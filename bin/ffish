#!/usr/bin/env ruby

# toggle gli debug info
ENV['GLI_DEBUG'] = 'true'
# DEBUG = true
DEBUG = false

require 'ffish'
require 'gli'

include GLI::App

version Ffish::VERSION
$MY_NAME_IS = File.basename($PROGRAM_NAME, '.*')
config_file File.join(ENV['HOME'], ".#{$MY_NAME_IS}rc.yaml")

# directory & file names
working_subdirectories = {
  :ffarm_dir => 'ffarm',
  :ffiles_dir => 'ffiles',
  :aux_dir => 'ffiles/aux',
  :ffish_dir => 'ffish'
}

state_file = 'ffish.yaml'
package_dir = 'packages'
logs_dir = 'logs'

# END directory & file names


program_desc 'Manage all your ffish.'

desc 'Set the options file'
long_desc """
Set the options file. Defaults to user's HOME/.#{$MY_NAME_IS}rc.yaml
"""
arg_name 'options_file'
default_value "~/#{$MY_NAME_IS}rc.yaml"
flag :options_file

desc 'Set the working direcotry'
long_desc """
Set the working direcorty. Defaults to user's HOME directory.
"""
arg_name 'working_directory' # this is where we keep the ffish
default_value "~/ffish"
flag :working_directory

pre do |global_options, command, options, args|
  # test for a working_directory, create it if not
  global_options[:work_dir] = File.expand_path global_options[:working_directory]
  global_options[:state_file] = File.join global_options[:work_dir], state_file
  
  working_subdirectories.each do |name, dir|
    global_options[name] = File.join global_options[:work_dir], dir

    unless File.directory? global_options[name]
      FileUtils.mkdir_p global_options[name]
    end
  end

  global_options[:packages_dir] = package_dir
  global_options[:logs_dir] = logs_dir

  unless File.exists? global_options[:state_file]
    FileUtils.touch global_options[:state_file]
  end

  # setup context
  global_options[:context] = {}

  true
end

# post do |global_options, command, options, args|
#   puts "SHIT HAPPENED"
# end

command :new do |c|
  c.desc 'Name of new ffish'
  c.arg_name 'ffish_names'

  c.action do |global_options, options, ffish_names|
    if ffish_names.empty?
      puts "Reading new ffish from stdin..."
      ffish_names = STDIN.readlines.map { |a| a.chomp }
    end

    Ffish::Ffish.new_ffish(global_options, ffish_names)
  end
end

desc 'List all the ffish'
long_desc """
"""

command :list do |c|
  c.desc 'List all ffish or list chunks in named ffish'
  c.arg_name 'ffish'
  c.switch 'c'

  c.action do |global_options, options, ffish|
    if options[:c]
      ffish = ffish[0]
    end
  
    Ffish::Ffish.list_ffish(global_options, ffish)
  end
end

desc 'Set or display the current ffish'
long_desc """
"""

command :current do |c|
  c.desc 'Current ffish'
  c.arg_name 'current_ffish'

  c.action do |global_options, options, current_ffish|
    Ffish::Ffish.current_ffish(global_options, current_ffish[0])
  end
end

desc 'Add a chunk to current ffish'
long_desc """
"""

command :add do |c|
  c.desc 'Add a chunk to current ffish'
  c.arg_name 'chunk_names'

  c.action do |global_options, options, chunk_names|
    if chunk_names.empty?
      puts "Reading new chunks from stdin..."
      chunk_names = STDIN.readlines.map { |a| a.chomp }
    end

    Ffish::Ffish.add_chunk(global_options, chunk_names)
  end
end

soft_commands = [:fetch, :configure, :make, :clean, :scrub, :test, :install, :build]

soft_commands.each do |new_command|
  desc 'Normal description'
  long_desc 'Long description'
  command new_command do |c|
    c.arg_name 'chunks'

    c.action do |global_options, options, chunks|
      Ffish::Ffish.do_ffish(global_options, c.names, chunks)
    end
  end
end

begin
  exit run(ARGV)
rescue GLI::UnknownCommand => ex
  # puts (ex.exception.methods - Object.methods)
  command = ex.exception.to_s.sub(/^Unknown command '(.+)'$/, '\1')
  puts "\t: #{ex.exception}"
  puts "\t: #{command}"
  puts "\t: #{GLI::AppSupport.exe_name}"

rescue Exception => ex
  # puts "TERMINATED: #{ex.message}"
  # puts "TERMINATED: #{ex.message.class}"
end
